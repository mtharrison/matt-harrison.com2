<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.74.1" />

  <title>BSprites:  Combined web assets using Typed Arrays and Data URIs &middot; Matt Harrison</title>

  <meta name="description" content="" />

  

<meta itemprop="name" content="BSprites:  Combined web assets using Typed Arrays and Data URIs">
<meta itemprop="description" content="Disclaimer: This was a weird idea I had one day and put this together the same evening. I&rsquo;ve not tested it cross-browser or in a production environment. I&rsquo;ve not benchmarked this either vs actually downloading all the images. It&rsquo;s kind of a &lsquo;what if&rsquo; project at the moment. If you think it&rsquo;s really dumb or cool, I&rsquo;d be really interested to hear your thoughts.
 Generally, whenever a browser loads a new image, it will make a new HTTP request to the server.">
<meta itemprop="datePublished" content="2014-07-28T00:00:00&#43;01:00" />
<meta itemprop="dateModified" content="2014-07-28T00:00:00&#43;01:00" />
<meta itemprop="wordCount" content="1055">



<meta itemprop="keywords" content="" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="BSprites:  Combined web assets using Typed Arrays and Data URIs"/>
<meta name="twitter:description" content="Disclaimer: This was a weird idea I had one day and put this together the same evening. I&rsquo;ve not tested it cross-browser or in a production environment. I&rsquo;ve not benchmarked this either vs actually downloading all the images. It&rsquo;s kind of a &lsquo;what if&rsquo; project at the moment. If you think it&rsquo;s really dumb or cool, I&rsquo;d be really interested to hear your thoughts.
 Generally, whenever a browser loads a new image, it will make a new HTTP request to the server."/>


<meta property="og:title" content="BSprites:  Combined web assets using Typed Arrays and Data URIs" />
<meta property="og:description" content="Disclaimer: This was a weird idea I had one day and put this together the same evening. I&rsquo;ve not tested it cross-browser or in a production environment. I&rsquo;ve not benchmarked this either vs actually downloading all the images. It&rsquo;s kind of a &lsquo;what if&rsquo; project at the moment. If you think it&rsquo;s really dumb or cool, I&rsquo;d be really interested to hear your thoughts.
 Generally, whenever a browser loads a new image, it will make a new HTTP request to the server." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://matt-harrison.com/posts/bsprites/" />
<meta property="article:published_time" content="2014-07-28T00:00:00+01:00" />
<meta property="article:modified_time" content="2014-07-28T00:00:00+01:00" />



  <link type="text/css"
        rel="stylesheet"
        href="/css/print.css"
        media="print">

  <link type="text/css"
        rel="stylesheet"
        href="/css/poole.css">

  <link type="text/css"
        rel="stylesheet"
        href="/css/hyde.css">

  
<style type="text/css">
  .sidebar {
    background-color: #141b19;
  }

  .read-more-link a {
    border-color: #141b19;
  }

  .pagination li a {
    color: #141b19;
    border: 1px solid #141b19;
  }

  .pagination li.active a {
    background-color: #141b19;
  }

  .pagination li a:hover {
    background-color: #141b19;
    opacity: 0.75;
  }

  footer a,
  .content a,
  .related-posts li a:hover {
    color: #141b19;
  }
</style>



  <link type="text/css" rel="stylesheet" href="/css/blog.css">

  <link rel="stylesheet"
        href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap">

  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css"
        integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk="
        crossorigin="anonymous" />

  <link rel="apple-touch-icon-precomposed"
        sizes="144x144"
        href="/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/favicon.png">

  
  </head>
<body>
  <aside class="sidebar">
    <div class="container">
      <div class="sidebar-about">
        
          
          <div class="author-image">
            <a href="/"><img src="/images/profile.jpg" class="img-circle img-headshot center" alt="Profile Picture"></a>
          </div>
          
        

        <h1><a href="/">Matt Harrison</a></h1>

        
        <p class="lead">Software and Machine Learning Engineer based in the UK</p>
        
      </div>

      <nav>
        <ul class="sidebar-nav">
          <li>
            <a href="https://github.com/mtharrison">GitHub</a>
          </li><li>
            <a href="https://docs.google.com/document/d/1bn7RvqlwSuPQTESZ0_2tVBr0EPw2vc1HhUo6eHf2W08/edit">Resume</a>
          </li>
        </ul>
      </nav>
    </div>
  </aside>


  <main class="content container">
  <div class="post">
  <h1>BSprites:  Combined web assets using Typed Arrays and Data URIs</h1>

  <div class="post-date">
    <time datetime="2014-07-28T00:00:00&#43;0100">Jul 28, 2014</time> &middot; 5 min read
  </div>

  <p><strong>Disclaimer:</strong> This was a weird idea I had one day and put this together the same evening. I&rsquo;ve not tested it cross-browser or in a production environment. I&rsquo;ve not benchmarked this either vs actually downloading all the images. It&rsquo;s kind of a &lsquo;what if&rsquo; project at the moment. If you think it&rsquo;s really dumb or cool, I&rsquo;d be really interested to hear your thoughts.</p>
<hr>
<p>Generally, whenever a browser loads a new image, it will make a new HTTP request to the server. This doesn&rsquo;t always mean establishing a new TCP connection, because browsers will leave TCP connections open for reuse if they&rsquo;re to the same hostname. However, these connections are managed by a &lsquo;connection pool&rsquo;. Most browsers do not do <a href="http://en.wikipedia.org/wiki/HTTP_pipelining">HTTP pipelining</a>, which means the connection waits for a response before sending a new request. This means your requests are queued. If you need to load 300 images from the same hostname this could have serious implications for your user experience.</p>
<h2 id="css-sprites">CSS sprites</h2>
<p>A strategy that people frequently use to mitigate this is to <em>visually</em> combine multiple images into a single image, which can then be served with a single HTTP request. This requires someone to lay out the images onto a larger canvas, at known pixel coordinates. The image is then positioned using CSS in the browser to reveal the individual images.</p>
<p><img src="https://mattharrison.s3.amazonaws.com/july2014/sprite.png" alt="CSS Sprite"></p>
<p>The drawbacks of this method are fairly obvious:</p>
<ul>
<li>Image metadata is opaque: Requires the consumer of the images to know at which coordinates to find the individual images, there&rsquo;s no way to serve these to some consumer you may not know, unless you also provide the metadata separately</li>
<li>You need to make another image file for every combination of images you wish to serve</li>
<li>If you need to add a new image, you have to recreate the sprite and update any metadata</li>
<li>All images within a sprite must be of the same content type e.g. <code>image/png</code>, <code>image/jpg</code> etc</li>
<li>Creating the images can be cumbersome and open to human error.</li>
</ul>
<h2 id="using-data-uris">Using data URIs</h2>
<p>Browsers have moved on quite a lot in the time the CSS sprite hack was established. There are 2 new features that open up other possibilities.</p>
<h3 id="data-uris">Data URIs</h3>
<p><a href="http://en.wikipedia.org/wiki/Data_URI_scheme">Data URIs</a> are a way to embed inline a resource as a base64 encoded string of the actual bytes that make up that resource. A data URI has the following form:</p>
<pre><code>data:[&lt;MIME-type&gt;][;charset=&lt;encoding&gt;][;base64],&lt;data&gt;
</code></pre>
<p>Data URIs can take the place of a URL in the <code>src</code> attribute of an image. Here&rsquo;s an example which is a small red dot:</p>
<pre><code>&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA
AAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO
9TXL0Y4OHwAAAABJRU5ErkJggg==&quot; alt=&quot;Red dot&quot; /&gt;
</code></pre>
<p>Data URIs can also be used in CSS:</p>
<pre><code>ul.checklist li.complete {
    padding-left: 20px;
    background: white url('data:image/png;base64,iVBORw0KGgoAA
AANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAABlBMVEUAAAD///+l2Z/dAAAAM0l
EQVR4nGP4/5/h/1+G/58ZDrAz3D/McH8yw83NDDeNGe4Ug9C9zwz3gVLMDA/A6
P9/AFGGFyjOXZtQAAAAAElFTkSuQmCC') no-repeat scroll left top;
}
</code></pre>
<p>This means if performance is critical to you, you can transfer a web page along with all images in a single HTTP request by including them inline in the HTML. Or with an extra request you can include them in the CSS.</p>
<p><em>Examples from <a href="http://en.wikipedia.org/wiki/Data_URI_scheme">Wikipedia</a></em></p>
<p><strong>Disadvantages to using data URIs</strong></p>
<p>There are however some disadvantages to the above:</p>
<ul>
<li>If the HTML/CSS is modified and invalidated in the browser cache, all your images need to be downloaded again even if they themselves haven&rsquo;t been modified</li>
<li>Encoding as Base64 takes up more space than the original binary data, meaning your image data is (~33%) heavier on the wire than if you just sent the image as binary data</li>
</ul>
<h3 id="arraybuffer">ArrayBuffer</h3>
<p>Javascript is traditionally unsuited to dealing with binary data, but modern browsers have <code>ArrayBuffer</code> which is a data type that points to a fixed size raw allocation of bytes in memory. The <code>ArrayBuffer</code> type can&rsquo;t be manipulated directly in Javascript, but you can create a &lsquo;view&rsquo; on a <code>ArrayBuffer</code> with Typed Arrays which can then be used to read/write data to the <code>arraybuffer</code>.</p>
<p>Typed arrays are like normal javascript arrays, except every element in the array is a fixed capacity number and they also have a <code>buffer</code> property that points to the underlying <code>arraybuffer</code>. The array elements will overflow, so if you have a <code>Uint8Array</code> with an element set to <code>255</code> and you add <code>1</code> to that element, it (and the underlying buffer) will overflow to <code>0</code>.</p>
<p>In the example below, an <code>ArrayBuffer</code> is instantiated with 2 bytes of memory. All the bits are set to 0 by default.</p>
<p>When creating a <code>Uint8Array</code> from this buffer, we get an array, whose <code>buffer</code> property points at our original buffer and contains the elements <code>[0,0]</code>.</p>
<p><img src="https://mattharrison.s3.amazonaws.com/july2014/array-buffer.png" alt="Typed arrays"></p>
<p>The <code>XMLHttpRequest</code> object in Javascript has a <code>responseType</code> property. This can be set to <code>arraybuffer</code> and will bypass any interpretation of the received data, instead just passing an <code>arraybuffer</code> object directly to the <code>onload</code> callback.</p>
<h2 id="a-new-approach-to-sprites">A new approach to sprites</h2>
<p>The disadvantages of CSS Sprites and embedding images with data URIs inside HTML and CSS can be overcome by:</p>
<ol>
<li>Serving the images separately to any HTML/CSS</li>
<li>Serving binary data rather than base64 encoded data</li>
<li>Serving the combined resource dynamically based on input parameters</li>
</ol>
<h3 id="server-side">Server side</h3>
<ul>
<li>Create a webservice that receives a request for a set of images e.g. <a href="http://service.com/images?img1.jpg&amp;img2.jpg">http://service.com/images?img1.jpg&amp;img2.jpg</a></li>
<li>Have the server sequentially read the raw bytes from each image file into a buffer</li>
<li>When reading each image, maintain a metadata data structure which keeps track of the byte positions of each image inside the buffer along with mime type and filename</li>
<li>Combine the metadata and all of the image data into a single binary buffer</li>
<li>Respond to a request with content-type <code>application/octet-stream</code> and the entire buffer as the response body</li>
<li>Also include a header <code>X-Metadata-Length</code> which tells the client how long the metadata header is in bytes</li>
</ul>
<p><img src="https://mattharrison.s3.amazonaws.com/july2014/server-side.png" alt="Server side"></p>
<h3 id="client-side">Client side</h3>
<ul>
<li>
<p>Request the data from the given URL, and specify the <code>xhr.responseType</code> as <code>arraybuffer</code></p>
<pre><code>  var request = new XMLHttpRequest();
  request.responseType = 'arraybuffer';
  request.open('GET', 'http://service.com/images?img1.jpg&amp;img2.jpg', true);
</code></pre>
</li>
<li>
<p>According to the value of the <code>X-Metadata-Offset</code> take a <code>slice()</code> from the buffer at the corresponding offset</p>
</li>
<li>
<p>Interpret the metadata chunk as a UTF-8 string and then parse as JSON.</p>
</li>
<li>
<p>Use the <code>slice()</code> method on the rest of the arraybuffer to create subarrays corresponding to each image</p>
</li>
</ul>
<ol start="7">
<li>Convert the array buffers to base64 strings</li>
<li>Create the <code>Image</code> DOM elements and set their Data URIs</li>
</ol>
<h2 id="example-implementations">Example Implementations</h2>
<h4 id="client-side-1">Client side</h4>
<p><a href="http://github.com/mtharrison/bsprite-client">github.com/mtharrison/bsprite-client</a> - A simple browser module for requesting bsprites from a compliant server.</p>
<h4 id="server-side-1">Server side</h4>
<p><a href="http://github.com/mtharrison/bsprite-go">github.com/mtharrison/bsprite-go</a> - A go package for creating and serving bsprites using <code>net/http</code>.</p>
<p>Node module coming soon too!</p>

</div>


  </main>

  <footer>
  <div>
    &copy; Matt Harrison 2023

    &middot; <a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">CC BY-SA 4.0</a>

    
  </div>
</footer>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js"
          integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0="
          crossorigin="anonymous"></script>

  <script src="/js/blog.js"></script>

  
</body>
</html>
