<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.74.1" />

  <title>Perfect web audio on iOS devices with the Web Audio API &middot; Matt Harrison</title>

  <meta name="description" content="" />

  

<meta itemprop="name" content="Perfect web audio on iOS devices with the Web Audio API">
<meta itemprop="description" content="TL;DR A lot of the restrictions imposed on the HTML5 audio element by iOS can be overcome by using the Web Audio API.
 If you&rsquo;ve ever built a web based game that requires sound effects, you&rsquo;ve no doubt felt the frustration of getting what is trivial to implement on desktop browsers to work smoothly on iOS devices.
Initally the obvious way to implement audio is to use the HTML5 &lt;audio&gt; element.">
<meta itemprop="datePublished" content="2014-01-02T00:00:00&#43;01:00" />
<meta itemprop="dateModified" content="2014-01-02T00:00:00&#43;01:00" />
<meta itemprop="wordCount" content="1276">



<meta itemprop="keywords" content="" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Perfect web audio on iOS devices with the Web Audio API"/>
<meta name="twitter:description" content="TL;DR A lot of the restrictions imposed on the HTML5 audio element by iOS can be overcome by using the Web Audio API.
 If you&rsquo;ve ever built a web based game that requires sound effects, you&rsquo;ve no doubt felt the frustration of getting what is trivial to implement on desktop browsers to work smoothly on iOS devices.
Initally the obvious way to implement audio is to use the HTML5 &lt;audio&gt; element."/>


<meta property="og:title" content="Perfect web audio on iOS devices with the Web Audio API" />
<meta property="og:description" content="TL;DR A lot of the restrictions imposed on the HTML5 audio element by iOS can be overcome by using the Web Audio API.
 If you&rsquo;ve ever built a web based game that requires sound effects, you&rsquo;ve no doubt felt the frustration of getting what is trivial to implement on desktop browsers to work smoothly on iOS devices.
Initally the obvious way to implement audio is to use the HTML5 &lt;audio&gt; element." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://matt-harrison.com/posts/web-audio/" />
<meta property="article:published_time" content="2014-01-02T00:00:00+01:00" />
<meta property="article:modified_time" content="2014-01-02T00:00:00+01:00" />



  <link type="text/css"
        rel="stylesheet"
        href="/css/print.css"
        media="print">

  <link type="text/css"
        rel="stylesheet"
        href="/css/poole.css">

  <link type="text/css"
        rel="stylesheet"
        href="/css/hyde.css">

  
<style type="text/css">
  .sidebar {
    background-color: #141b19;
  }

  .read-more-link a {
    border-color: #141b19;
  }

  .pagination li a {
    color: #141b19;
    border: 1px solid #141b19;
  }

  .pagination li.active a {
    background-color: #141b19;
  }

  .pagination li a:hover {
    background-color: #141b19;
    opacity: 0.75;
  }

  footer a,
  .content a,
  .related-posts li a:hover {
    color: #141b19;
  }
</style>



  <link type="text/css" rel="stylesheet" href="/css/blog.css">

  <link rel="stylesheet"
        href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap">

  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css"
        integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk="
        crossorigin="anonymous" />

  <link rel="apple-touch-icon-precomposed"
        sizes="144x144"
        href="/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/favicon.png">

  
  </head>
<body>
  <aside class="sidebar">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2897591057477195"
     crossorigin="anonymous"></script>
    <div class="container">
      <div class="sidebar-about">
        
          
          <div class="author-image">
            <a href="/"><img src="/images/profile.jpg" class="img-circle img-headshot center" alt="Profile Picture"></a>
          </div>
          
        

        <h1><a href="/">Matt Harrison</a></h1>

        
        <p class="lead">Software and Machine Learning Engineer based in the UK</p>
        
      </div>

      <nav>
        <ul class="sidebar-nav">
          <li>
            <a href="https://github.com/mtharrison">GitHub</a>
          </li><li>
            <a href="https://docs.google.com/document/d/1bn7RvqlwSuPQTESZ0_2tVBr0EPw2vc1HhUo6eHf2W08/edit">Resume</a>
          </li>
        </ul>
      </nav>
    </div>
  </aside>


  <main class="content container">
  <div class="post">
  <h1>Perfect web audio on iOS devices with the Web Audio API</h1>

  <div class="post-date">
    <time datetime="2014-01-02T00:00:00&#43;0100">Jan 2, 2014</time> &middot; 6 min read
  </div>

  <p>TL;DR A lot of the restrictions imposed on the HTML5 audio element by iOS can be overcome by using the <a href="#webAudio">Web Audio API</a>.</p>
<hr>
<p>If you&rsquo;ve ever built a web based game that requires sound effects, you&rsquo;ve no doubt felt the frustration of getting what is trivial to implement on desktop browsers to work smoothly on iOS devices.</p>
<p>Initally the obvious way to implement audio is to use the HTML5 &lt;audio&gt; element. The official browser support for the element is widespread enough to coax you into a false sense of security (<a href="http://caniuse.com/audio)">http://caniuse.com/audio)</a>.</p>
<p>You could go ahead and put all your sound effects in separate &lt;audio&gt; elements like so:</p>
<pre><code class="language-markup">&lt;audio id="blast" src="blast.mp3">&lt;/audio>
&lt;audio id="smash" src="smash.mp3">&lt;/audio>
&lt;audio id="pow" src="pow.mp3">&lt;/audio>
&lt;audio id="bang" src="bang.mp3">&lt;/audio>
&lt;!-- Background Track -->
&lt;audio id="smooth-jazz" src="smooth-jazz.mp3" autoplay>&lt;/audio>
</code></pre>
<p>Then say you have a gun trigger with a class of <code>blasterTrigger</code>:</p>
<pre><code class="language-markup">&lt;button class="blasterTrigger">Shoot!&lt;/button>
</code></pre>
<p>You could then use the Javascript API to control the playing of the blast sound when the trigger is clicked like so:</p>
<pre><code class="language-javascript">var blasterTrigger = document.querySelector(".blasterTrigger");
blasterTrigger.addEventListener("click", function(){
    document.getElementById("blast").play();
});
</code></pre>
<br>
###The hunch
<p>If you test the above code in most desktop browers, you&rsquo;ll find it works perfectly (given you provide a suitable audio format for that browser). If you take out your iPad though and give it a go, you&rsquo;ll find the background track doesn&rsquo;t play at all.</p>
<p>Also, if you try to fire any of the other sounds simultaneously, you&rsquo;ll probably only hear one. Asyncronous sounds (i.e. ones that are fired in code and not in the call stack of a UI interaction like a click or touch event) won&rsquo;t play at all.</p>
<p>The problem is that even though Safari on iOS <em>does</em>  support the audio element, it imposes some restrictions of its own on playback. These restrictions are driven by a desire to save the user bandwidth and memory. Some have suggested Apple have done this because they want to keep media rich applications to be native and sold through the App Store.</p>
<p>The iOS restrictions basically sum up like this:</p>
<ul>
<li>
<p>Only 1 channel of audio can play at a time so no layering or overlapping of sounds. This really restricts you if you want to have background audio in your game</p>
</li>
<li>
<p>iOS will ignore the autoplay attribute on your elements</p>
</li>
<li>
<p>You can&rsquo;t load your audio tracks asyncronously, they must be loaded via a UI interaction like a click event.</p>
</li>
</ul>
<p>####Possible solutions</p>
<p>There are a few method to attempt to overcome the limitations of the &lt;audio&gt; element on iOS.</p>
<p><strong>Queueing</strong></p>
<p>One approach is to have a single audio channel and queue the tracks you wish to play on a single queue to get played sequentially.</p>
<pre><code class="language-markup">&lt;audio id=&quot;vivaldi&quot; src=&quot;vivaldi.mp3&quot;&gt;&lt;/audio&gt;
&lt;audio id=&quot;brahms&quot; src=&quot;brahms.mp3&quot;&gt;&lt;/audio&gt;
&lt;audio id=&quot;mozart&quot; src=&quot;mozart.mp3&quot;&gt;&lt;/audio&gt;
&lt;button data-track=&quot;vivaldi&quot;&gt;Play Vivaldi&lt;/button&gt;
&lt;button data-track=&quot;brahms&quot;&gt;Play Brahms&lt;/button&gt;
&lt;button data-track=&quot;mozart&quot;&gt;Play Mozart&lt;/button&gt;
</code></pre>
<pre><code class="language-javascript">var buttons,
    addToPlayQueue,
    track,
    trackEnded,
    i,
    queue = [],
    isPlaying = false,
    tracks;

buttons = document.getElementsByTagName("button");
tracks = document.getElementsByTagName("audio");

addToPlayQueue = function (event) {
    event.preventDefault();
    var track = this.dataset.track;
    queue.push(track);
};

trackEnded = function (event) {
    console.log("Track just ended");
    isPlaying = false;
};

for (i = 0; i < buttons.length; i++)
    buttons[i].addEventListener("click", addToPlayQueue);

for (i = 0; i < tracks.length; i++)
    tracks[i].addEventListener("ended", trackEnded);

//Run loop
setInterval(function () {
    if (queue.length > 0 && isPlaying === false) {
        document.getElementById(queue.pop()).play();
        isPlaying = true;
    }
}, 500);</code></pre>
<br>
**Audiosprites**
<p>Another approach is to use audiosprites (think CSS sprites but audio files). This is where you combine all your audio files into a single track separated by silence. To play a particular sound, you just seek to that time and start playing.</p>
<p>There are various tools to help with the creation and playing of these. There&rsquo;s an NPM package <a href="https://github.com/tonistiigi/audiosprite">https://github.com/tonistiigi/audiosprite</a> which is a wrapper around <em>ffmpeg</em> that will create your sprites in many formats and output a handy JSON file with the timing of the various tracks encoded within. I originally used this approach, letting a <a href="http://gruntjs.com/">Grunt</a> task manage the creation of the sprites from my sources files as part of the build process. There was also a library from <a href="http://zynga.com/">Zynga</a> called Jukebox that could take these JSON files and expose a convenient API for playing tracks (that implemented a similar run loop and queueing approach as above) but as of Jan 2014 it seems to have been taken down from Github.</p>
<p>Although this approach certainly is an improvement and overcome several of the issues, it&rsquo;s still not perfect. You can still only play one track and a time and if you queue tracks in quick succession, no matter how good your queue implementation, iOS will sometimes just discard the operation.</p>
<p>Luckily, there is another solution…enter the Web Audio API.</p>
<h3 id="webAudio">Web Audio API</h3>
<p>The web audio API is a new standard by the w3c that has started appearing in browsers. It’s supported in the most recent versions of Firefox, Chrome and safari (including iOS6/7). Check <a href="http://caniuse.com/audio-api">http://caniuse.com/audio-api</a> for up to date support information.</p>
<p>It is designed for sophisticated audio sythesis and manipulation and its architecture is modelled around professional sound engineering techniques.</p>
<p>It can however be used to play a basic audio buffer, including looping and stopping the track. It doesn’t (currently) suffer the same limitations as the HTML audio element and it’s Javascript API making it a viable candidate for web based games with sound effects. Using it on iOS sidesteps the single-channel restriction.</p>
<p>The underlying API is optimised at the C++/Assesmbly level so it’s very fast and has a low consumption of memory.</p>
<p>Here&rsquo;s some sample code that I wrote that uses the Web Audio API and acts as a shim for iOS devices to take place of the library (buzz.js) we&rsquo;re using for desktop browsers.</p>
<pre><code class="language-javascript">try {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    window.audioContext = new window.AudioContext();
} catch (e) {
    console.log("No Web Audio API support");
}

/*
 * WebAudioAPISoundManager Constructor
 */
 var WebAudioAPISoundManager = function (context) {
    this.context = context;
    this.bufferList = {};
    this.playingSounds = {};
};

/*
 * WebAudioAPISoundManager Prototype
 */
WebAudioAPISoundManager.prototype = {
     addSound: function (url) {
        // Load buffer asynchronously
        var request = new XMLHttpRequest();
        request.open("GET", url, true);
        request.responseType = "arraybuffer";

        var self = this;

        request.onload = function () {
            // Asynchronously decode the audio file data in request.response
            self.context.decodeAudioData(
                request.response,

                function (buffer) {
                    if (!buffer) {
                        alert('error decoding file data: ' + url);
                        return;
                    }
                    self.bufferList[url] = buffer;
                });
        };

        request.onerror = function () {
            alert('BufferLoader: XHR error');
        };

        request.send();
    },
    stopSoundWithUrl: function(url) {
        if(this.playingSounds.hasOwnProperty(url)){
            for(var i in this.playingSounds[url]){
                if(this.playingSounds[url].hasOwnProperty(i))
                    this.playingSounds[url][i].noteOff(0);
            }
        }
    }
};

/*
 * WebAudioAPISound Constructor
 */
 var WebAudioAPISound = function (url, options) {
    this.settings = {
        loop: false
    };

    for(var i in options){
        if(options.hasOwnProperty(i))
            this.settings[i] = options[i];
    }

    this.url = url + '.mp3';
    window.webAudioAPISoundManager = window.webAudioAPISoundManager || new WebAudioAPISoundManager(window.audioContext);
    this.manager = window.webAudioAPISoundManager;
    this.manager.addSound(this.url);
};

/*
 * WebAudioAPISound Prototype
 */
WebAudioAPISound.prototype = {
    play: function () {
        var buffer = this.manager.bufferList[this.url];
        //Only play if it's loaded yet
        if (typeof buffer !== "undefined") {
            var source = this.makeSource(buffer);
            source.loop = this.settings.loop;
            source.noteOn(0);

            if(!this.manager.playingSounds.hasOwnProperty(this.url))
                this.manager.playingSounds[this.url] = [];
            this.manager.playingSounds[this.url].push(source);
        }
    },
    stop: function () {
        this.manager.stopSoundWithUrl(this.url);
    },
    getVolume: function () {
        return this.translateVolume(this.volume, true);
    },
    //Expect to receive in range 0-100
    setVolume: function (volume) {
        this.volume = this.translateVolume(volume);
    },
    translateVolume: function(volume, inverse){
        return inverse ? volume * 100 : volume / 100;
    },
    makeSource: function (buffer) {
        var source = this.manager.context.createBufferSource();
        var gainNode = this.manager.context.createGainNode();
        gainNode.gain.value = this.volume;
        source.buffer = buffer;
        source.connect(gainNode);
        gainNode.connect(this.manager.context.destination);
        return source;
    }
};</code></pre>
<p>The <code>WebAudioAPISound</code> class can then be used like so:</p>
<pre><code class="language-javascript">var blastSound, smashSound, backgroundMusic;

blastSound = new WebAudioAPISound("blast.mp3");
smashSound = new WebAudioAPISound("smash.mp3");
backgroundMusic = new WebAudioAPISound("smooth-jazz.mp3", {loop: true});

backgroundMusic.play();
blastSound.play();
smashSound.play();

//Play background music for 30 seconds
setTimeout(function(){
    backgroundMusic.stop();
}, 30 * 1000);</code></pre>
<p>You should find that your audio (including background track) all now works seemlessly on iOS devices.</p>
<p>I&rsquo;ve found the following sources useful in writing this:</p>
<ol>
<li><a href="http://www.html5rocks.com/en/tutorials/webaudio/games/">http://www.html5rocks.com/en/tutorials/webaudio/games/</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/webaudio/intro/">http://www.html5rocks.com/en/tutorials/webaudio/intro/</a></li>
</ol>
<p>Please feel free to leave comments if you like this or think something could be improved.</p>

</div>


  </main>

  <footer>
  <div>
    &copy; Matt Harrison 2024

    &middot; <a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">CC BY-SA 4.0</a>

    
  </div>
</footer>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js"
          integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0="
          crossorigin="anonymous"></script>

  <script src="/js/blog.js"></script>

  
</body>
</html>
